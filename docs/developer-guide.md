# Agent Role Play 운영 가이드 (개발자용)

네 가지 에이전트(PM, 프론트엔드, 서버, 문서화)가 문서 기반으로 매끄럽게 협업하도록 업무 지시·검수 방식과 커뮤니케이션 규칙을 정의합니다.

## 1. 기본 원칙

- 문서 우선: 모든 요청·결정·리스크를 템플릿 기반 문서로 남긴다(`docs/templates` 활용).
- 단일 책임자: 각 업무는 하나의 책임 에이전트가 오너가 된다(공동 작업 시 역할을 명시).
- 추적 가능성: 지시 → 작업 기록 → 결과 보고 → 의사결정이 한 스레드로 연결되도록 `docs/threads/`에 기록한다.
- 짧은 주기 공유: 상태/차단 요소를 짧게라도 하루 1회 남긴다(stand-up 템플릿 권장).

## 2. 에이전트 역할 요약

- PM: 업무 지시/우선순위, 의존성 정리, 완료 승인.
- 프론트엔드: UI/UX 구현, 인터랙션·상태관리, 프론트 테스트.
- 서버: API·데이터모델 설계/구현, 배포/운영 체크.
- 문서화: 산출물 구조화, 가이드/릴리스 노트 작성, 기록 정합성 확인.

## 3. 업무 진행 흐름 (문서 기준)

1. 개시: PM이 `docs/templates/task-brief.md`로 지시서 작성 → `docs/threads/YYYY-MM-DD-주제.md`에 붙여넣고 오너/마감/우선순위/완료조건 정의.
2. 실행: 각 에이전트는 질문·리스크를 `docs/templates/issue-log.md` 포맷으로 같은 스레드에 추가, 의사결정은 `decision-record.md` 포맷으로 기록.
3. 결과: 작업자는 `task-report.md`로 결과 보고서를 같은 스레드에 남기고, 관련 산출물 링크를 명시.
4. 검수: PM/문서화 에이전트가 체크리스트로 승인 여부 판단 후, 결정문서(`decision-record`)에 “승인/보완요청” 기록.
5. 후속: 필요 시 다음 작업 지시서를 같은 스레드 하위 섹션에 생성하거나 새 스레드를 연다(주제 단위로 스레드를 가볍게 유지).

## 4. 지시서 작성 규격 (요청 시 꼭 채우기)

`task-brief` 템플릿을 사용하며, 최소 항목:

- 목표/배경: 왜 하는지, 성공 정의(숫자/사용자 시나리오).
- Scope In/Out: 포함·제외 범위, 선행/후행 작업.
- 요구사항: 기능/UX/성능/보안 등 명시적 요구.
- 산출물 & 완료조건: 파일/PR/데모/문서 형태와 품질 기준.
- 우선순위/마감: 절대 마감일, 중간 점검일.
- 의존성/제약: API, 디자인, 계정, 환경 등.
- 테스트 기대: 필수 테스트 리스트(수동/자동), 수용 기준.
- 리뷰어/승인자: 코드/문서 검토 담당 명시.

예시 지시 블록(threads 파일에 붙여넣기):

```
## [지시] FE - 프로필 카드 1차
- 목표: 사용자 대시보드에 프로필 카드 추가, 모바일 360px 이상 대응.
- Scope: In - 이름/직함/현재 회사/배지; Out - 편집 기능.
- 산출물: PR 링크, 스토리북 스토리 1개, 스냅샷 테스트.
- 마감/체크인: 6/12 EOD, 중간 점검 6/11 오전.
- 의존성: API GET /profile v1 확정 필요(서버팀).
- 테스트: 모바일/데스크톱 크로스브라우저 수동 체크, Jest 스냅샷.
- 리뷰어: 서버(계약 필드 확인), 문서화(용어/텍스트 톤).
```

## 5. 검수/리뷰 체크리스트

공통(모든 결과 보고서 기준):

- 요구사항-산출물 매핑: 지시서 항목별로 결과 보고서에 대응 링크가 있는가.
- 품질 근거: 테스트 결과/스크린샷/로그 등이 증빙으로 포함됐는가.
- 리스크 처리: 오픈 이슈가 `issue-log`로 정리되고 차단 여부가 명확한가.
- 결정 기록: 중요한 선택지가 `decision-record`로 남았는가.

프론트엔드 검수:

- UI 일관성: 디자인 스펙/반응형/접근성(포커스, 키보드, 대체 텍스트) 확인.
- 상태/오류: 빈 상태, 로딩, 실패 UI가 구현·테스트됐는가.
- 빌드/테스트: linters/test 통과 증빙, 스토리북/스크린샷 링크.

서버 검수:

- 계약 준수: API 스펙, 응답 스키마, 에러 코드가 지시서와 일치하는가.
- 안정성: 로그/메트릭 포인트, 실패 재시도·타임아웃 등 회복력 확인.
- 보안/성능: 인증/인가, 입력 검증, N+1/캐싱 여부, 마이그레이션 절차.

문서화 검수:

- 최신성: 결과 보고서, README/가이드, 결정 기록 간 내용이 일치하는가.
- 재현성: 로컬 실행/배포 절차가 누락 없이 따라 할 수 있는가.
- 톤/용어: 서비스 표준 용어/스타일 가이드에 맞는가.

## 6. 커뮤니케이션 규칙 (스레드 운용)

- 파일 위치: 모든 협업 기록은 `docs/threads/날짜-주제.md`에 시간 순으로 append.
- 업데이트 형식: `[날짜] 진행/차단/다음 액션` 3줄로 짧게 남긴다.
- 질문 우선순위: 차단 이슈는 `issue-log`로 남기고 @오너 호출, 기타는 댓글 섹션에 묶는다.
- 승인 라벨: 스레드에 “승인됨/보완필요/블록됨” 텍스트 라벨을 남겨 상태를 명확히 한다.

## 7. 폴더/파일 네이밍 가이드

- threads 파일: `YYYY-MM-DD-핵심주제.md` (예: `2024-06-10-profile-card.md`)
- 섹션: `[지시]`, `[업데이트]`, `[결과]`, `[결정]`, `[이슈]` 접두어 사용으로 스캔 용이성 확보.
- 산출물 링크: 코드(PR/커밋), 디자인, 데이터, 로그, 데모 URL을 결과 보고서에 모두 기입.

## 8. 코드 레포 연동(서브모듈 전략)

문서/운영 레포(이 레포)를 단일 소스로 두고, 서버/플러터 코드 레포에 `docs/` 경로로 서브모듈을 연결합니다.

### A) 초기 설정(레포별 1회)

```
# 코드 레포 루트에서
git submodule add git submodule add https://github.com/KoreanTuna/Agent-Role-Play docs
 docs
git submodule update --init --recursive
git commit -am "chore: add ops-docs submodule"
```

- 클론 시: `git clone --recurse-submodules <code-repo-url>`
- 기존 클론: `git submodule update --init --recursive`

### B) 작업 플로우(에이전트 공통)

- 문서 생성/수정은 항상 서브모듈 루트(`docs/threads/...`, `docs/templates/...`)에서 커밋 → `ops-docs` 브랜치로 PR.
- 코드 PR 설명에 반드시 해당 스레드 경로/링크를 적는다(누락 시 PR 템플릿이 체크).
- 문서 머지 후 코드 레포 서브모듈 포인터 업데이트:

```
git submodule update --remote docs
git add docs
git commit -m "chore: bump docs"
```

### C) PR 템플릿 예시(코드 레포 `.github/pull_request_template.md`)

```
## Docs
- [ ] docs 스레드 링크: docs/threads/2024-06-11-feature-x.md
```

### D) CI 세팅(코드 레포)

- GitHub Actions: `actions/checkout@v4`에 `submodules: true` 옵션 추가로 docs 폴더 포함.
- 문서 빌드/테스트는 돌리지 말고(속도 저하), 스레드 링크 필수 확인만 유지.

### E) 운용 팁

- 권한: 모든 에이전트가 ops-docs 레포에 동일한 쓰기 권한을 가진다.
- 분리 배포: 스토어 심사 지연 등과 무관하게 문서 기록은 ops-docs에서만 이어간다.
- 네이밍: 스레드 파일명/섹션 접두어 규칙은 7장과 동일하게 유지.
